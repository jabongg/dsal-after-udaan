Let A be a non-empty array consisting of N integers.

The abs sum of two for a pair of indices (P, Q) is the absolute value |A[P] + A[Q]|, for 0 ≤ P ≤ Q < N.

For example, the following array A:

  A[0] =  1
  A[1] =  4
  A[2] = -3
has pairs of indices (0, 0), (0, 1), (0, 2), (1, 1), (1, 2), (2, 2).
The abs sum of two for the pair (0, 0) is A[0] + A[0] = |1 + 1| = 2.
The abs sum of two for the pair (0, 1) is A[0] + A[1] = |1 + 4| = 5.
The abs sum of two for the pair (0, 2) is A[0] + A[2] = |1 + (−3)| = 2.
The abs sum of two for the pair (1, 1) is A[1] + A[1] = |4 + 4| = 8.
The abs sum of two for the pair (1, 2) is A[1] + A[2] = |4 + (−3)| = 1.
The abs sum of two for the pair (2, 2) is A[2] + A[2] = |(−3) + (−3)| = 6.


given a non-empty array A consisting of N integers, returns the minimal abs sum of two for any pair of indices in this array.

For example, given the following array A:

  A[0] =  1
  A[1] =  4
  A[2] = -3
the output should be 1, as explained above.
...
 * each element of array A is an integer within the range [−1,000,000,000..1,000,000,000].
 * Complexity:
 * expected worst-case time complexity is O(N*log(N));
 * expected worst-case space complexity is O(N), beyond input storage (not counting the storage required for input arguments).
 * Elements of input arrays can be modified.
 */
import java.util.Arrays;

class Solution {
    public int solution(int[] A) {
        int N = A.length;
        Arrays.sort(A);
        int tail = 0;
        int head = N - 1;
        int minAbsSum = Math.abs(A[tail] + A[head]);
        while (tail <= head) {
            int currentSum = A[tail] + A[head];
            minAbsSum = Math.min(minAbsSum, Math.abs(currentSum));
            // If the sum has become
            // positive, we should know that the head can be moved left
            if (currentSum <= 0)
                tail++;
            else
                head--;
        }
        return minAbsSum;
    }
}
/*Score: 100%*/
Footer


====
A : 1, 4, -3,

stack.push(A[i]);




j -> i stack

min sum
sum/ abso
public fin

==================================================================================================

grtInt() // returns a random integer

n times

Output: k largest integers

====

int[] k =

grtInt() {
	Random random
}


// heap empty

if (empty()) {
push(el)
}

if (k == heap.siZe())

for (int i < k);


log(k)
...
import java.io.*;
import java.util.*;

class GFG{

public static void FirstKelements(int arr[],
								int size,
								int k)
{

	// Creating Min Heap for given
	// array with only k elements
	// Create min heap with priority queue
	PriorityQueue<Integer> minHeap = new PriorityQueue<>();
	for(int i = 0; i < k; i++)
	{
		minHeap.add(arr[i]);
	}

	// Loop For each element in array
	// after the kth element
	for(int i = k; i < size; i++)
	{

		// If current element is smaller
		// than minimum ((top element of
		// the minHeap) element, do nothing
		// and continue to next element
		if (minHeap.peek() > arr[i])
			continue;

		// Otherwise Change minimum element
		// (top element of the minHeap) to
		// current element by polling out
		// the top element of the minHeap
		else
		{
			minHeap.poll();
			minHeap.add(arr[i]);
		}
	}

	// Now min heap contains k maximum
	// elements, Iterate and print
	Iterator iterator = minHeap.iterator();

	while (iterator.hasNext())
	{
		System.out.print(iterator.next() + " ");
	}
}

// Driver code
public static void main (String[] args)
{
	int arr[] = { 11, 3, 2, 1, 15, 5, 4,
				45, 88, 96, 50, 45 };

	int size = arr.length;

	// Size of Min Heap
	int k = 3;

	FirstKelements(arr, size, k);
}
}

// This code is contributed by Vansh Sethi


==========================================


You are given coins of different denominations, represented by an array - coins of size n.
You are also given a value - target. Find the different number of combinations that make up the amount target.
Assume that you have infinite number of each kind of coin.

Example
coins: [5, 2, 4]
target: 13
Result: 3
Explanation: The three ways are-
2, 2, 2, 2, 5
2, 2, 4, 5
4, 4, 5







// Recursive JAVA program for
// coin change problem.
import java.util.*;
class GFG {

	// Returns the count of ways we can
	// sum coins[0...n-1] coins to get sum "sum"
	static int count(int coins[], int n, int sum)
	{

		// If sum is 0 then there is 1 solution
		// (do not include any coin)
		if (sum == 0)
			return 1;

		// If sum is less than 0 then no
		// solution exists
		if (sum < 0)
			return 0;

		// If there are no coins and sum
		// is greater than 0, then no
		// solution exist
		if (n <= 0)
			return 0;

		// count is sum of solutions (i)
		// including coins[n-1] (ii) excluding coins[n-1]
		return count(coins, n - 1, sum)
			+ count(coins, n, sum - coins[n - 1]);
	}

	// Driver code
	public static void main(String args[])
	{
		int coins[] = { 1, 2, 3 };
		int n = coins.length;

		System.out.println(count(coins, n, 4));
	}
}

// This code is contributed by jyoti369





